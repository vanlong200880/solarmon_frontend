{"ast":null,"code":"/**\n * Howdo\n * 适应了 global 与 window\n * @author ydr.me\n * @create 2014年7月26日19:28:27\n * @update 2014年8月26日13:09:31\n * @update 2014年10月24日00:24:32\n * @update 2015年02月04日11:42:57\n * @update 2015年07月01日17:35:20\n * @update 2015年11月27日10:57:12@3.0.0\n */\n'use strict';\n\nvar _global = typeof window !== 'undefined' ? window : global;\n\nvar slice = Array.prototype.slice;\n\nvar noop = function noop() {// ignore\n};\n/**\n * 判断是否为函数\n * @param obj\n * @returns {boolean}\n */\n\n\nvar isFunction = function isFunction(obj) {\n  return typeof obj === 'function';\n};\n/**\n * 遍历\n * @param object\n * @param callback\n */\n\n\nvar _each = function each(object, callback) {\n  var i;\n  var j;\n\n  if (object && object.constructor === Array) {\n    for (i = 0, j = object.length; i < j; i++) {\n      if (callback(i, object[i]) === false) {\n        break;\n      }\n    }\n  } else if (typeof object === \"object\") {\n    for (i in object) {\n      if (object.hasOwnProperty && object.hasOwnProperty(i)) {\n        if (callback(i, object[i]) === false) {\n          break;\n        }\n      } else {\n        if (callback(i, object[i]) === false) {\n          break;\n        }\n      }\n    }\n  }\n};\n/**\n * 下一次\n * @param callback\n */\n\n\nvar nextTick = function nextTick(callback) {\n  setTimeout(callback, 0);\n};\n\nmodule.exports = {\n  task: function task() {\n    if (this.constructor === Howdo) {\n      return this;\n    }\n\n    var args = slice.call(arguments);\n    var howdo = new Howdo();\n    return howdo.task.apply(howdo, args);\n  },\n  each: function each() {\n    if (this.constructor === Howdo) {\n      return this;\n    }\n\n    var args = slice.call(arguments);\n    var howdo = new Howdo();\n    return howdo.each.apply(howdo, args);\n  }\n}; //////////////////////////////////////////////////////////////////////\n/////////////////////////[ constructor ]//////////////////////////////\n//////////////////////////////////////////////////////////////////////\n// 构造函数\n\nfunction Howdo() {\n  var the = this;\n  the._executed = false;\n  the._ignoreErr = false;\n  the._taskIndex = -1;\n  the._taskList = [];\n  the._tryCallbackList = [];\n  the._catchCallbackList = [];\n  the._contextList = [];\n  the._allCallback = null;\n}\n\nHowdo.prototype = {\n  constructor: Howdo,\n\n  /**\n   * 单次分配任务\n   * @param {Function} fn 任务函数\n   * @return Howdo\n   * @chainable\n   */\n  task: function task(fn) {\n    var the = this;\n\n    if (!isFunction(fn)) {\n      throw new TypeError('howdo `task` must be a function');\n    }\n\n    the._taskIndex++;\n\n    the._taskList.push(fn);\n\n    the._contextList.push({\n      index: the._taskIndex,\n      task: fn\n    });\n\n    return the;\n  },\n\n  /**\n   * 添加任务回退方法\n   * @param rollback {Function} 回退、中止方法\n   * @returns {Howdo}\n   */\n  rollback: function rollback(_rollback) {\n    var the = this;\n\n    if (the._taskIndex > -1 && isFunction(_rollback)) {\n      the._contextList[the._taskIndex].rollback = _rollback;\n    }\n\n    return the;\n  },\n\n  /**\n   * 添加任务回退方法\n   * @param abort {Function} 回退、中止方法\n   * @returns {Howdo}\n   */\n  abort: function abort(_abort) {\n    var the = this;\n\n    if (the._taskIndex > -1 && isFunction(_abort)) {\n      the._contextList[the._taskIndex].abort = _abort;\n    }\n\n    return the;\n  },\n\n  /**\n   * 直到 结束\n   * @param fn {Function} 验证函数\n   * @param [ignoreError] {Boolean} 是否忽略错误\n   * @returns {Howdo}\n   */\n  until: function until(fn, ignoreError) {\n    var the = this;\n\n    if (!isFunction(fn)) {\n      throw new TypeError('until `condition` must be a function');\n    }\n\n    the._untilCondition = fn;\n    the._ignoreErr = ignoreError !== false;\n    return the;\n  },\n\n  /**\n   * 循环分配任务\n   * @param  {Object}   object   对象或者数组\n   * @param  {Function} callback 回调\n   * @return Howdo\n   */\n  each: function each(object, callback) {\n    var howdo = this;\n\n    _each(object, task);\n\n    function task(key, val) {\n      howdo = howdo.task(function () {\n        var args = [key, val];\n        args = args.concat(slice.call(arguments));\n        callback.apply(val, args);\n      });\n    }\n\n    return howdo;\n  },\n\n  /**\n   * 跟着做，任务串行执行\n   * 链式结束\n   * @param [callback] {Function} 回调\n   */\n  follow: function follow(callback) {\n    var the = this;\n\n    if (the._executed) {\n      return the;\n    }\n\n    if (!isFunction(callback)) {\n      callback = noop;\n    }\n\n    the._allCallback = callback;\n    the._executed = true;\n    var current = 0;\n    var count = the._taskList.length;\n    var args = []; // 串行回退已成功的任务\n\n    var rollbackTask = function rollbackTask() {\n      _each(the._contextList, function (index, context) {\n        if (!context) {\n          return false;\n        }\n\n        if (!context.error && isFunction(context.rollback)) {\n          context.rollback.call(context);\n          context.error = null;\n        }\n      });\n    };\n\n    nextTick(function () {\n      if (!count) {\n        the._fixCallback();\n\n        return the;\n      }\n\n      (function _follow() {\n        var fn = function fn() {\n          args = slice.call(arguments);\n          var error = args[0]; // has error\n\n          if (error && !the._ignoreErr) {\n            context.error = error;\n            rollbackTask();\n            return the._fixCallback(error);\n          }\n\n          current++;\n          var canStop = false;\n\n          if (the._untilCondition) {\n            // 一轮任务完成\n            if (current === count) {\n              canStop = the._untilCondition.apply(_global, args.slice(1));\n              current += canStop ? 0 : -count;\n            }\n          } else {\n            canStop = current === count;\n          }\n\n          if (canStop) {\n            rollbackTask();\n\n            the._fixCallback.apply(the, args);\n          } else if (current < count) {\n            args.shift();\n\n            _follow();\n          }\n        };\n\n        args.unshift(fn);\n        var task = the._taskList[current];\n        var context = the._contextList[current];\n        task.apply(context, args);\n      })();\n    });\n    return the;\n  },\n\n  /**\n   * 一起做，任务并行执行\n   * 链式结束\n   * @param [callback] {Function} 回调\n   */\n  together: function together(callback) {\n    var the = this;\n\n    if (the._executed) {\n      return;\n    }\n\n    if (!isFunction(callback)) {\n      callback = noop;\n    }\n\n    the._allCallback = callback;\n    the._executed = true;\n    var doneLength = 0;\n    var count = the._taskList.length;\n    var taskData = [];\n    var hasCallback = false;\n    var i = 0; // 中止未完成的 task\n\n    var abortTask = function abortTask() {\n      hasCallback = true;\n\n      _each(the._contextList, function (index, context) {\n        if (!context.done && isFunction(context.abort)) {\n          context.abort.call(context);\n        }\n      });\n    }; // 回退已经完成的 task\n\n\n    var rollbackTask = function rollbackTask() {\n      _each(the._contextList, function (index, context) {\n        if (context.done && isFunction(context.rollback)) {\n          context.rollback.call(context);\n        }\n      });\n    };\n\n    nextTick(function () {\n      if (!count) {\n        hasCallback = true;\n\n        the._fixCallback();\n\n        return the;\n      }\n\n      for (; i < count; i++) {\n        _doTask(i, the._taskList[i]);\n      }\n\n      function _doTask(index, task) {\n        var context = the._contextList[index];\n\n        var fn = function fn() {\n          if (hasCallback) {\n            return;\n          }\n\n          var args = slice.call(arguments);\n          var ret = [];\n          var j = 0;\n          context.done = true; // has Error\n\n          if (args[0] && !the._ignoreErr) {\n            abortTask();\n            rollbackTask();\n            return the._fixCallback(args[0]);\n          }\n\n          var canStop = false;\n          var value = args.slice(1);\n\n          if (the._untilCondition) {\n            canStop = the._untilCondition.apply(_global, value);\n\n            if (canStop) {\n              doneLength = count;\n            } else {\n              doneLength++;\n            }\n\n            if (doneLength === count) {\n              if (canStop) {\n                ret = ret.concat(value);\n              }\n\n              ret.unshift(null);\n              abortTask();\n\n              the._fixCallback.apply(the, ret);\n            }\n          } else {\n            doneLength++;\n            taskData[index] = value;\n\n            if (doneLength === count) {\n              for (; j < taskData.length; j++) {\n                ret = ret.concat(taskData[j]);\n              }\n\n              ret.unshift(null);\n              abortTask();\n\n              the._fixCallback.apply(the, ret);\n            }\n          }\n        };\n\n        task.call(context, fn);\n      }\n    });\n    return the;\n  },\n\n  /**\n   * 正常回调\n   * @param callback\n   */\n  try: function _try(callback) {\n    var the = this;\n\n    if (isFunction(callback)) {\n      the._tryCallbackList.push(callback);\n    }\n\n    return the;\n  },\n\n  /**\n   * 异常回调\n   * @param callback\n   */\n  catch: function _catch(callback) {\n    var the = this;\n\n    if (isFunction(callback)) {\n      the._catchCallbackList.push(callback);\n    }\n\n    return the;\n  },\n\n  /**\n   * 修正回调\n   * @param err\n   * @private\n   */\n  _fixCallback: function _fixCallback(err\n  /*arguments*/\n  ) {\n    var the = this;\n    var args = slice.call(arguments, 1);\n\n    the._allCallback.apply(_global, arguments);\n\n    if (err) {\n      return _each(the._catchCallbackList, function (i, callback) {\n        callback.call(_global, err);\n      });\n    }\n\n    _each(the._tryCallbackList, function (i, callback) {\n      callback.apply(_global, args);\n    });\n  }\n}; //Howdo.prototype.serial = Howdo.prototype.follow;\n//Howdo.prototype.parallel = Howdo.prototype.together;","map":{"version":3,"sources":["/Volumes/Data/sources/solarmon_production/solarmon_frontend/node_modules/howdo/howdo.js"],"names":["_global","window","global","slice","Array","prototype","noop","isFunction","obj","each","object","callback","i","j","constructor","length","hasOwnProperty","nextTick","setTimeout","module","exports","task","Howdo","args","call","arguments","howdo","apply","the","_executed","_ignoreErr","_taskIndex","_taskList","_tryCallbackList","_catchCallbackList","_contextList","_allCallback","fn","TypeError","push","index","rollback","abort","until","ignoreError","_untilCondition","key","val","concat","follow","current","count","rollbackTask","context","error","_fixCallback","_follow","canStop","shift","unshift","together","doneLength","taskData","hasCallback","abortTask","done","_doTask","ret","value","try","catch","err"],"mappings":"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","sourcesContent":["/**\n * Howdo\n * 适应了 global 与 window\n * @author ydr.me\n * @create 2014年7月26日19:28:27\n * @update 2014年8月26日13:09:31\n * @update 2014年10月24日00:24:32\n * @update 2015年02月04日11:42:57\n * @update 2015年07月01日17:35:20\n * @update 2015年11月27日10:57:12@3.0.0\n */\n\n\n'use strict';\n\nvar _global = typeof window !== 'undefined' ? window : global;\nvar slice = Array.prototype.slice;\nvar noop = function () {\n    // ignore\n};\n/**\n * 判断是否为函数\n * @param obj\n * @returns {boolean}\n */\nvar isFunction = function (obj) {\n    return typeof obj === 'function';\n};\n\n\n/**\n * 遍历\n * @param object\n * @param callback\n */\nvar each = function (object, callback) {\n    var i;\n    var j;\n\n    if (object && object.constructor === Array) {\n        for (i = 0, j = object.length; i < j; i++) {\n            if (callback(i, object[i]) === false) {\n                break;\n            }\n        }\n    } else if (typeof object === \"object\") {\n        for (i in object) {\n            if (object.hasOwnProperty && object.hasOwnProperty(i)) {\n                if (callback(i, object[i]) === false) {\n                    break;\n                }\n            } else {\n                if (callback(i, object[i]) === false) {\n                    break;\n                }\n            }\n        }\n    }\n};\n\n/**\n * 下一次\n * @param callback\n */\nvar nextTick = function (callback) {\n    setTimeout(callback, 0);\n};\n\nmodule.exports = {\n    task: function () {\n        if (this.constructor === Howdo) {\n            return this;\n        }\n\n        var args = slice.call(arguments);\n        var howdo = new Howdo();\n\n        return howdo.task.apply(howdo, args);\n    },\n    each: function () {\n        if (this.constructor === Howdo) {\n            return this;\n        }\n\n        var args = slice.call(arguments);\n        var howdo = new Howdo();\n\n        return howdo.each.apply(howdo, args);\n    }\n};\n\n\n//////////////////////////////////////////////////////////////////////\n/////////////////////////[ constructor ]//////////////////////////////\n//////////////////////////////////////////////////////////////////////\n\n// 构造函数\nfunction Howdo() {\n    var the = this;\n\n    the._executed = false;\n    the._ignoreErr = false;\n    the._taskIndex = -1;\n    the._taskList = [];\n    the._tryCallbackList = [];\n    the._catchCallbackList = [];\n    the._contextList = [];\n    the._allCallback = null;\n}\n\nHowdo.prototype = {\n    constructor: Howdo,\n\n    /**\n     * 单次分配任务\n     * @param {Function} fn 任务函数\n     * @return Howdo\n     * @chainable\n     */\n    task: function (fn) {\n        var the = this;\n\n        if (!isFunction(fn)) {\n            throw new TypeError('howdo `task` must be a function');\n        }\n\n        the._taskIndex++;\n        the._taskList.push(fn);\n        the._contextList.push({\n            index: the._taskIndex,\n            task: fn\n        });\n\n        return the;\n    },\n\n\n    /**\n     * 添加任务回退方法\n     * @param rollback {Function} 回退、中止方法\n     * @returns {Howdo}\n     */\n    rollback: function (rollback) {\n        var the = this;\n\n        if (the._taskIndex > -1 && isFunction(rollback)) {\n            the._contextList[the._taskIndex].rollback = rollback;\n        }\n\n        return the;\n    },\n\n\n    /**\n     * 添加任务回退方法\n     * @param abort {Function} 回退、中止方法\n     * @returns {Howdo}\n     */\n    abort: function (abort) {\n        var the = this;\n\n        if (the._taskIndex > -1 && isFunction(abort)) {\n            the._contextList[the._taskIndex].abort = abort;\n        }\n\n        return the;\n    },\n\n\n    /**\n     * 直到 结束\n     * @param fn {Function} 验证函数\n     * @param [ignoreError] {Boolean} 是否忽略错误\n     * @returns {Howdo}\n     */\n    until: function (fn, ignoreError) {\n        var the = this;\n\n        if (!isFunction(fn)) {\n            throw new TypeError('until `condition` must be a function');\n        }\n\n        the._untilCondition = fn;\n        the._ignoreErr = ignoreError !== false;\n\n        return the;\n    },\n\n\n    /**\n     * 循环分配任务\n     * @param  {Object}   object   对象或者数组\n     * @param  {Function} callback 回调\n     * @return Howdo\n     */\n    each: function (object, callback) {\n        var howdo = this;\n\n        each(object, task);\n\n        function task(key, val) {\n            howdo = howdo.task(function () {\n                var args = [key, val];\n                args = args.concat(slice.call(arguments));\n                callback.apply(val, args);\n            });\n        }\n\n        return howdo;\n    },\n\n\n    /**\n     * 跟着做，任务串行执行\n     * 链式结束\n     * @param [callback] {Function} 回调\n     */\n    follow: function (callback) {\n        var the = this;\n\n        if (the._executed) {\n            return the;\n        }\n\n        if (!isFunction(callback)) {\n            callback = noop;\n        }\n\n        the._allCallback = callback;\n        the._executed = true;\n\n        var current = 0;\n        var count = the._taskList.length;\n        var args = [];\n        // 串行回退已成功的任务\n        var rollbackTask = function () {\n            each(the._contextList, function (index, context) {\n                if (!context) {\n                    return false;\n                }\n\n                if (!context.error && isFunction(context.rollback)) {\n                    context.rollback.call(context);\n                    context.error = null;\n                }\n            });\n        };\n\n        nextTick(function () {\n            if (!count) {\n                the._fixCallback();\n                return the;\n            }\n\n            (function _follow() {\n                var fn = function () {\n                    args = slice.call(arguments);\n                    var error = args[0];\n\n                    // has error\n                    if (error && !the._ignoreErr) {\n                        context.error = error;\n                        rollbackTask();\n                        return the._fixCallback(error);\n                    }\n\n                    current++;\n\n                    var canStop = false;\n\n                    if (the._untilCondition) {\n                        // 一轮任务完成\n                        if (current === count) {\n                            canStop = the._untilCondition.apply(_global, args.slice(1));\n                            current += canStop ? 0 : -count;\n                        }\n                    } else {\n                        canStop = current === count;\n                    }\n\n                    if (canStop) {\n                        rollbackTask();\n                        the._fixCallback.apply(the, args);\n                    } else if (current < count) {\n                        args.shift();\n                        _follow();\n                    }\n                };\n\n                args.unshift(fn);\n                var task = the._taskList[current];\n                var context = the._contextList[current];\n                task.apply(context, args);\n            })();\n        });\n\n        return the;\n    },\n\n    /**\n     * 一起做，任务并行执行\n     * 链式结束\n     * @param [callback] {Function} 回调\n     */\n    together: function (callback) {\n        var the = this;\n\n        if (the._executed) {\n            return;\n        }\n\n        if (!isFunction(callback)) {\n            callback = noop;\n        }\n\n        the._allCallback = callback;\n        the._executed = true;\n\n        var doneLength = 0;\n        var count = the._taskList.length;\n        var taskData = [];\n        var hasCallback = false;\n        var i = 0;\n\n        // 中止未完成的 task\n        var abortTask = function () {\n            hasCallback = true;\n            each(the._contextList, function (index, context) {\n                if (!context.done && isFunction(context.abort)) {\n                    context.abort.call(context);\n                }\n            });\n        };\n\n        // 回退已经完成的 task\n        var rollbackTask = function () {\n            each(the._contextList, function (index, context) {\n                if (context.done && isFunction(context.rollback)) {\n                    context.rollback.call(context);\n                }\n            });\n        };\n\n        nextTick(function () {\n            if (!count) {\n                hasCallback = true;\n                the._fixCallback();\n                return the;\n            }\n\n            for (; i < count; i++) {\n                _doTask(i, the._taskList[i]);\n            }\n\n            function _doTask(index, task) {\n                var context = the._contextList[index];\n                var fn = function () {\n                    if (hasCallback) {\n                        return;\n                    }\n\n                    var args = slice.call(arguments);\n                    var ret = [];\n                    var j = 0;\n\n                    context.done = true;\n\n                    // has Error\n                    if (args[0] && !the._ignoreErr) {\n                        abortTask();\n                        rollbackTask();\n                        return the._fixCallback(args[0]);\n                    }\n\n                    var canStop = false;\n                    var value = args.slice(1);\n\n                    if (the._untilCondition) {\n                        canStop = the._untilCondition.apply(_global, value);\n\n                        if (canStop) {\n                            doneLength = count;\n                        } else {\n                            doneLength++;\n                        }\n\n                        if (doneLength === count) {\n                            if (canStop) {\n                                ret = ret.concat(value);\n                            }\n\n                            ret.unshift(null);\n                            abortTask();\n                            the._fixCallback.apply(the, ret);\n                        }\n                    } else {\n                        doneLength++;\n                        taskData[index] = value;\n\n                        if (doneLength === count) {\n                            for (; j < taskData.length; j++) {\n                                ret = ret.concat(taskData[j]);\n                            }\n\n                            ret.unshift(null);\n                            abortTask();\n                            the._fixCallback.apply(the, ret);\n                        }\n                    }\n                };\n\n                task.call(context, fn);\n            }\n        });\n\n        return the;\n    },\n\n    /**\n     * 正常回调\n     * @param callback\n     */\n    try: function (callback) {\n        var the = this;\n\n        if (isFunction(callback)) {\n            the._tryCallbackList.push(callback);\n        }\n\n        return the;\n    },\n\n    /**\n     * 异常回调\n     * @param callback\n     */\n    catch: function (callback) {\n        var the = this;\n\n        if (isFunction(callback)) {\n            the._catchCallbackList.push(callback);\n        }\n\n        return the;\n    },\n\n    /**\n     * 修正回调\n     * @param err\n     * @private\n     */\n    _fixCallback: function (err/*arguments*/) {\n        var the = this;\n        var args = slice.call(arguments, 1);\n\n        the._allCallback.apply(_global, arguments);\n\n        if (err) {\n            return each(the._catchCallbackList, function (i, callback) {\n                callback.call(_global, err);\n            });\n        }\n\n        each(the._tryCallbackList, function (i, callback) {\n            callback.apply(_global, args);\n        });\n    }\n};\n\n//Howdo.prototype.serial = Howdo.prototype.follow;\n//Howdo.prototype.parallel = Howdo.prototype.together;\n"]},"metadata":{},"sourceType":"script"}