{"ast":null,"code":"/**\n * 类的创建与继承\n * @author ydr.me\n * @create 2014-10-04 15:09\n */ /*===============================\n // 【以前】\n // 创建一个类\n var A = function(){};\n A.prototype.abc = '123';\n\n // 继承一个类\n var B = function(){\n A.apply(this, arguments);\n };\n\n B.prototype = new A();\n B.prototype.def = '456';\n\n // ===>\n\n //【现在】\n var A = klass.create({\n constructor: function(){},\n abc: '123'\n });\n var B = klass.extends(A).create({\n constructor: function(){},\n def: '456'\n });\n ===============================*/ /**\n * 类方法\n * @module class\n * @requires dato\n * @requires typeis\n */var dato=require('./dato.js');var typeis=require('./typeis.js');var classId=0;/**\n * 单继承\n * @param {Function} constructor 子类\n * @param {Function} superConstructor 父类\n * @param {Boolean} [isCopyStatic=false] 是否复制静态方法\n * @link https://github.com/joyent/node/blob/master/lib/util.js#L628\n *\n * @example\n * // 父类\n * var Father = function(){};\n *\n * // 子类\n * var Child = function(){\n     *     // 执行一次父类的方法\n     *     Father.apply(this, arguments);\n     *\n     *     // 这里执行子类的方法、属性\n     *     this.sth = 123;\n     * };\n *\n * klass.inherit(Child, Father);\n *\n * // 这里开始写子类的原型方法\n * Child.prototype.fn = fn;\n */var inherit=function inherit(constructor,superConstructor,isCopyStatic){constructor.super_=superConstructor;constructor.prototype=Object.create(superConstructor.prototype);if(isCopyStatic){dato.extend(true,constructor,superConstructor);}};/**\n * 创建一个类（构造函数）【旧的方法，会在下一个大版本中废弃】\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n */var _create=function create(prototypes,superConstructor,isInheritStatic){if(typeis.Function(prototypes)){prototypes={constructor:prototypes};}if(!typeis.Function(prototypes.constructor)){throw Error('propertypes.constructor must be a function');}var con=prototypes.constructor;prototypes.constructor=null;var superConstructorIsAFn=typeis.Function(superConstructor);var Class=function Class(){var the=this;var args=arguments;if(superConstructorIsAFn){superConstructor.apply(the,args);}the.__classId__=classId++;con.apply(the,args);};if(superConstructorIsAFn){inherit(Class,superConstructor,isInheritStatic);}dato.each(prototypes,function(key,val){Class.prototype[key]=val;});/**\n     * 原始的 constructor\n     * @type {Function}\n     * @private\n     */Class.prototype.__constructor__=con;/**\n     * 输出的 constructor\n     * @type {Function}\n     */Class.prototype.constructor=Class;return Class;};/**\n * 类的构造器\n * @param prototypes\n * @param superConstructor\n * @param isInheritStatic\n * @constructor\n */var Class=function Class(prototypes,superConstructor,isInheritStatic){var the=this;the.p=prototypes;the.s=superConstructor;the.i=isInheritStatic;};Class.prototype={constructor:Class,/**\n     * 类的创建\n     * @param {Object} [prototypes] 原型链\n     * @returns {Function}\n     */create:function create(prototypes){var the=this;the.p=prototypes||the.p;return _create(the.p,the.s,the.i);}};/**\n * 类的继承，参考了 es6 的 class 表现\n * 因为 extends 是关键字，在 IE 下会报错，修改为 extend、inherit\n * @param superConstructor\n * @param isInheritStatic\n * @returns {Class}\n */exports['extends']=exports.extend=function(superConstructor,isInheritStatic){return new Class(null,superConstructor,isInheritStatic);};/**\n * 类的创建\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n *\n * @example\n * // 1. 创建一个空原型链的类\n * var A = klass.create(fn);\n *\n * // 2. 创建一个有原型链的类\n * var B = klass.create({\n     *     constructor: fn,\n     *     ...\n     * });\n *\n * // 3. 创建一个子类\n * var C = klass.extend(B).create(fn);\n * var D = klass.extend(C).create({\n     *     constructor: fn,\n     *     ...\n     * });\n */exports.create=function(prototypes,superConstructor,isInheritStatic){var the=this;// 上一个级联应该是 extends\nif(the.constructor===Class&&the instanceof Class){return the.create(prototypes);}return new Class(prototypes,superConstructor,isInheritStatic).create();};/**\n * 原型转让，将父级的原型复制到子类，\n * 比如写好的一个 Dialog 类有 A、B、C 三个原型方法，\n * 而写好的一个子类 ProductDialog，与 Dialog 的构造参数不一致，无法直接继承，\n * 那么就可以使用原型过渡，子类的 ProductDialog 原本没有 A、B、C 三个实例方法，\n * 只是在内部实例化了一个 Dialog 实例 dialog，那么就可以将 dialog 的原型方法复制到 ProductDialog 实例上\n * 即：`class.transfer(Dialog, ProductDialog, 'dialog')`\n * 结果是：将 Dialog 的原型通过 dialog 实例转让给 ProductDialog\n *\n * @param parentClass {Function|Object} 父级构造函数\n * @param childClass {Function} 子级构造函数\n * @param parentInstanceNameInChild {String} 父级实例在子类的名称\n * @param [filter] {Array} 允许和禁止的公共方法名称\n *\n * @example\n * name 与 ['name'] 匹配\n * name 与 ['!name'] 不匹配\n */exports.transfer=function(parentClass,childClass,parentInstanceNameInChild,filter){dato.each(parentClass.prototype,function(property){if(!childClass.prototype[property]&&_matches(property,filter)){childClass.prototype[property]=function(){var the=this;var ret=the[parentInstanceNameInChild][property].apply(the[parentInstanceNameInChild],arguments);return ret instanceof parentClass?the:ret;};}});};var REG_PRIVATE=/^_/;/**\n * 判断是否匹配\n * @param name {String} 待匹配字符串\n * @param [names] {Array} 被匹配字符串数组\n * @returns {boolean}\n * @private\n */function _matches(name,names){names=names||[];if(REG_PRIVATE.test(name)){return false;}if(!names.length){return true;}var matched=true;dato.each(names,function(index,_name){var flag=_name[0];// !name\nif(flag==='!'){matched=true;if(name===_name.slice(1)){matched=false;return false;}}// name\nelse{matched=false;if(name===_name){matched=true;return false;}}});return matched;}","map":{"version":3,"sources":["/Volumes/Data/sources/solarmon_production/solarmon_frontend/src/validator/libs/class.js"],"names":["dato","require","typeis","classId","inherit","constructor","superConstructor","isCopyStatic","super_","prototype","Object","create","extend","prototypes","isInheritStatic","Function","Error","con","superConstructorIsAFn","Class","the","args","arguments","apply","__classId__","each","key","val","__constructor__","p","s","i","exports","transfer","parentClass","childClass","parentInstanceNameInChild","filter","property","_matches","ret","REG_PRIVATE","name","names","test","length","matched","index","_name","flag","slice"],"mappings":"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","sourcesContent":["/**\n * 类的创建与继承\n * @author ydr.me\n * @create 2014-10-04 15:09\n */\n\n/*===============================\n // 【以前】\n // 创建一个类\n var A = function(){};\n A.prototype.abc = '123';\n\n // 继承一个类\n var B = function(){\n A.apply(this, arguments);\n };\n\n B.prototype = new A();\n B.prototype.def = '456';\n\n // ===>\n\n //【现在】\n var A = klass.create({\n constructor: function(){},\n abc: '123'\n });\n var B = klass.extends(A).create({\n constructor: function(){},\n def: '456'\n });\n ===============================*/\n\n\n/**\n * 类方法\n * @module class\n * @requires dato\n * @requires typeis\n */\n\nvar dato = require('./dato.js');\nvar typeis = require('./typeis.js');\n\nvar classId = 0;\n\n/**\n * 单继承\n * @param {Function} constructor 子类\n * @param {Function} superConstructor 父类\n * @param {Boolean} [isCopyStatic=false] 是否复制静态方法\n * @link https://github.com/joyent/node/blob/master/lib/util.js#L628\n *\n * @example\n * // 父类\n * var Father = function(){};\n *\n * // 子类\n * var Child = function(){\n     *     // 执行一次父类的方法\n     *     Father.apply(this, arguments);\n     *\n     *     // 这里执行子类的方法、属性\n     *     this.sth = 123;\n     * };\n *\n * klass.inherit(Child, Father);\n *\n * // 这里开始写子类的原型方法\n * Child.prototype.fn = fn;\n */\nvar inherit = function (constructor, superConstructor, isCopyStatic) {\n    constructor.super_ = superConstructor;\n    constructor.prototype = Object.create(superConstructor.prototype);\n\n    if (isCopyStatic) {\n        dato.extend(true, constructor, superConstructor);\n    }\n};\n\n\n/**\n * 创建一个类（构造函数）【旧的方法，会在下一个大版本中废弃】\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n */\nvar create = function (prototypes, superConstructor, isInheritStatic) {\n    if (typeis.Function(prototypes)) {\n        prototypes = {\n            constructor: prototypes\n        };\n    }\n\n    if (!typeis.Function(prototypes.constructor)) {\n        throw Error('propertypes.constructor must be a function');\n    }\n\n    var con = prototypes.constructor;\n\n    prototypes.constructor = null;\n\n    var superConstructorIsAFn = typeis.Function(superConstructor);\n    var Class = function () {\n        var the = this;\n        var args = arguments;\n\n        if (superConstructorIsAFn) {\n            superConstructor.apply(the, args);\n        }\n\n        the.__classId__ = classId++;\n        con.apply(the, args);\n    };\n\n    if (superConstructorIsAFn) {\n        inherit(Class, superConstructor, isInheritStatic);\n    }\n\n    dato.each(prototypes, function (key, val) {\n        Class.prototype[key] = val;\n    });\n\n    /**\n     * 原始的 constructor\n     * @type {Function}\n     * @private\n     */\n    Class.prototype.__constructor__ = con;\n\n    /**\n     * 输出的 constructor\n     * @type {Function}\n     */\n    Class.prototype.constructor = Class;\n\n    return Class;\n};\n\n\n/**\n * 类的构造器\n * @param prototypes\n * @param superConstructor\n * @param isInheritStatic\n * @constructor\n */\nvar Class = function (prototypes, superConstructor, isInheritStatic) {\n    var the = this;\n\n    the.p = prototypes;\n    the.s = superConstructor;\n    the.i = isInheritStatic;\n};\n\nClass.prototype = {\n    constructor: Class,\n\n    /**\n     * 类的创建\n     * @param {Object} [prototypes] 原型链\n     * @returns {Function}\n     */\n    create: function (prototypes) {\n        var the = this;\n\n        the.p = prototypes || the.p;\n\n        return create(the.p, the.s, the.i);\n    }\n};\n\n\n/**\n * 类的继承，参考了 es6 的 class 表现\n * 因为 extends 是关键字，在 IE 下会报错，修改为 extend、inherit\n * @param superConstructor\n * @param isInheritStatic\n * @returns {Class}\n */\nexports['extends'] = exports.extend = function (superConstructor, isInheritStatic) {\n    return new Class(null, superConstructor, isInheritStatic);\n};\n\n\n/**\n * 类的创建\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n *\n * @example\n * // 1. 创建一个空原型链的类\n * var A = klass.create(fn);\n *\n * // 2. 创建一个有原型链的类\n * var B = klass.create({\n     *     constructor: fn,\n     *     ...\n     * });\n *\n * // 3. 创建一个子类\n * var C = klass.extend(B).create(fn);\n * var D = klass.extend(C).create({\n     *     constructor: fn,\n     *     ...\n     * });\n */\nexports.create = function (prototypes, superConstructor, isInheritStatic) {\n    var the = this;\n\n    // 上一个级联应该是 extends\n    if (the.constructor === Class && the instanceof Class) {\n        return the.create(prototypes);\n    }\n\n    return new Class(prototypes, superConstructor, isInheritStatic).create();\n};\n\n\n/**\n * 原型转让，将父级的原型复制到子类，\n * 比如写好的一个 Dialog 类有 A、B、C 三个原型方法，\n * 而写好的一个子类 ProductDialog，与 Dialog 的构造参数不一致，无法直接继承，\n * 那么就可以使用原型过渡，子类的 ProductDialog 原本没有 A、B、C 三个实例方法，\n * 只是在内部实例化了一个 Dialog 实例 dialog，那么就可以将 dialog 的原型方法复制到 ProductDialog 实例上\n * 即：`class.transfer(Dialog, ProductDialog, 'dialog')`\n * 结果是：将 Dialog 的原型通过 dialog 实例转让给 ProductDialog\n *\n * @param parentClass {Function|Object} 父级构造函数\n * @param childClass {Function} 子级构造函数\n * @param parentInstanceNameInChild {String} 父级实例在子类的名称\n * @param [filter] {Array} 允许和禁止的公共方法名称\n *\n * @example\n * name 与 ['name'] 匹配\n * name 与 ['!name'] 不匹配\n */\nexports.transfer = function (parentClass, childClass, parentInstanceNameInChild, filter) {\n    dato.each(parentClass.prototype, function (property) {\n        if (!childClass.prototype[property] && _matches(property, filter)) {\n            childClass.prototype[property] = function () {\n                var the = this;\n                var ret = the[parentInstanceNameInChild][property].apply(the[parentInstanceNameInChild], arguments);\n                return ret instanceof parentClass ? the : ret;\n            };\n        }\n    });\n};\n\n\nvar REG_PRIVATE = /^_/;\n\n/**\n * 判断是否匹配\n * @param name {String} 待匹配字符串\n * @param [names] {Array} 被匹配字符串数组\n * @returns {boolean}\n * @private\n */\nfunction _matches(name, names) {\n    names = names || [];\n\n    if (REG_PRIVATE.test(name)) {\n        return false;\n    }\n\n    if (!names.length) {\n        return true;\n    }\n\n    var matched = true;\n\n    dato.each(names, function (index, _name) {\n        var flag = _name[0];\n\n        // !name\n        if (flag === '!') {\n            matched = true;\n\n            if (name === _name.slice(1)) {\n                matched = false;\n                return false;\n            }\n        }\n        // name\n        else {\n            matched = false;\n\n            if (name === _name) {\n                matched = true;\n                return false;\n            }\n        }\n    });\n\n    return matched;\n}"]},"metadata":{},"sourceType":"module"}