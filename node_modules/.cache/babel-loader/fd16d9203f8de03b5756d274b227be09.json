{"ast":null,"code":"/**\n * 类的创建与继承\n * @author ydr.me\n * @create 2014-10-04 15:09\n */\n\n/*===============================\n // 【以前】\n // 创建一个类\n var A = function(){};\n A.prototype.abc = '123';\n\n // 继承一个类\n var B = function(){\n A.apply(this, arguments);\n };\n\n B.prototype = new A();\n B.prototype.def = '456';\n\n // ===>\n\n //【现在】\n var A = klass.create({\n constructor: function(){},\n abc: '123'\n });\n var B = klass.extends(A).create({\n constructor: function(){},\n def: '456'\n });\n ===============================*/\n\n/**\n * 类方法\n * @module class\n * @requires dato\n * @requires typeis\n */\nvar dato = require('./dato.js');\n\nvar typeis = require('./typeis.js');\n\nvar classId = 0;\n/**\n * 单继承\n * @param {Function} constructor 子类\n * @param {Function} superConstructor 父类\n * @param {Boolean} [isCopyStatic=false] 是否复制静态方法\n * @link https://github.com/joyent/node/blob/master/lib/util.js#L628\n *\n * @example\n * // 父类\n * var Father = function(){};\n *\n * // 子类\n * var Child = function(){\n     *     // 执行一次父类的方法\n     *     Father.apply(this, arguments);\n     *\n     *     // 这里执行子类的方法、属性\n     *     this.sth = 123;\n     * };\n *\n * klass.inherit(Child, Father);\n *\n * // 这里开始写子类的原型方法\n * Child.prototype.fn = fn;\n */\n\nvar inherit = function (constructor, superConstructor, isCopyStatic) {\n  constructor.super_ = superConstructor;\n  constructor.prototype = Object.create(superConstructor.prototype);\n\n  if (isCopyStatic) {\n    dato.extend(true, constructor, superConstructor);\n  }\n};\n/**\n * 创建一个类（构造函数）【旧的方法，会在下一个大版本中废弃】\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n */\n\n\nvar create = function (prototypes, superConstructor, isInheritStatic) {\n  if (typeis.Function(prototypes)) {\n    prototypes = {\n      constructor: prototypes\n    };\n  }\n\n  if (!typeis.Function(prototypes.constructor)) {\n    throw Error('propertypes.constructor must be a function');\n  }\n\n  var con = prototypes.constructor;\n  prototypes.constructor = null;\n  var superConstructorIsAFn = typeis.Function(superConstructor);\n\n  var Class = function () {\n    var the = this;\n    var args = arguments;\n\n    if (superConstructorIsAFn) {\n      superConstructor.apply(the, args);\n    }\n\n    the.__classId__ = classId++;\n    con.apply(the, args);\n  };\n\n  if (superConstructorIsAFn) {\n    inherit(Class, superConstructor, isInheritStatic);\n  }\n\n  dato.each(prototypes, function (key, val) {\n    Class.prototype[key] = val;\n  });\n  /**\n   * 原始的 constructor\n   * @type {Function}\n   * @private\n   */\n\n  Class.prototype.__constructor__ = con;\n  /**\n   * 输出的 constructor\n   * @type {Function}\n   */\n\n  Class.prototype.constructor = Class;\n  return Class;\n};\n/**\n * 类的构造器\n * @param prototypes\n * @param superConstructor\n * @param isInheritStatic\n * @constructor\n */\n\n\nvar Class = function (prototypes, superConstructor, isInheritStatic) {\n  var the = this;\n  the.p = prototypes;\n  the.s = superConstructor;\n  the.i = isInheritStatic;\n};\n\n_c = Class;\nClass.prototype = {\n  constructor: Class,\n\n  /**\n   * 类的创建\n   * @param {Object} [prototypes] 原型链\n   * @returns {Function}\n   */\n  create: function (prototypes) {\n    var the = this;\n    the.p = prototypes || the.p;\n    return create(the.p, the.s, the.i);\n  }\n};\n/**\n * 类的继承，参考了 es6 的 class 表现\n * 因为 extends 是关键字，在 IE 下会报错，修改为 extend、inherit\n * @param superConstructor\n * @param isInheritStatic\n * @returns {Class}\n */\n\nexports['extends'] = exports.extend = function (superConstructor, isInheritStatic) {\n  return new Class(null, superConstructor, isInheritStatic);\n};\n/**\n * 类的创建\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n *\n * @example\n * // 1. 创建一个空原型链的类\n * var A = klass.create(fn);\n *\n * // 2. 创建一个有原型链的类\n * var B = klass.create({\n     *     constructor: fn,\n     *     ...\n     * });\n *\n * // 3. 创建一个子类\n * var C = klass.extend(B).create(fn);\n * var D = klass.extend(C).create({\n     *     constructor: fn,\n     *     ...\n     * });\n */\n\n\nexports.create = function (prototypes, superConstructor, isInheritStatic) {\n  var the = this; // 上一个级联应该是 extends\n\n  if (the.constructor === Class && the instanceof Class) {\n    return the.create(prototypes);\n  }\n\n  return new Class(prototypes, superConstructor, isInheritStatic).create();\n};\n/**\n * 原型转让，将父级的原型复制到子类，\n * 比如写好的一个 Dialog 类有 A、B、C 三个原型方法，\n * 而写好的一个子类 ProductDialog，与 Dialog 的构造参数不一致，无法直接继承，\n * 那么就可以使用原型过渡，子类的 ProductDialog 原本没有 A、B、C 三个实例方法，\n * 只是在内部实例化了一个 Dialog 实例 dialog，那么就可以将 dialog 的原型方法复制到 ProductDialog 实例上\n * 即：`class.transfer(Dialog, ProductDialog, 'dialog')`\n * 结果是：将 Dialog 的原型通过 dialog 实例转让给 ProductDialog\n *\n * @param parentClass {Function|Object} 父级构造函数\n * @param childClass {Function} 子级构造函数\n * @param parentInstanceNameInChild {String} 父级实例在子类的名称\n * @param [filter] {Array} 允许和禁止的公共方法名称\n *\n * @example\n * name 与 ['name'] 匹配\n * name 与 ['!name'] 不匹配\n */\n\n\nexports.transfer = function (parentClass, childClass, parentInstanceNameInChild, filter) {\n  dato.each(parentClass.prototype, function (property) {\n    if (!childClass.prototype[property] && _matches(property, filter)) {\n      childClass.prototype[property] = function () {\n        var the = this;\n        var ret = the[parentInstanceNameInChild][property].apply(the[parentInstanceNameInChild], arguments);\n        return ret instanceof parentClass ? the : ret;\n      };\n    }\n  });\n};\n\nvar REG_PRIVATE = /^_/;\n/**\n * 判断是否匹配\n * @param name {String} 待匹配字符串\n * @param [names] {Array} 被匹配字符串数组\n * @returns {boolean}\n * @private\n */\n\nfunction _matches(name, names) {\n  names = names || [];\n\n  if (REG_PRIVATE.test(name)) {\n    return false;\n  }\n\n  if (!names.length) {\n    return true;\n  }\n\n  var matched = true;\n  dato.each(names, function (index, _name) {\n    var flag = _name[0]; // !name\n\n    if (flag === '!') {\n      matched = true;\n\n      if (name === _name.slice(1)) {\n        matched = false;\n        return false;\n      }\n    } // name\n    else {\n        matched = false;\n\n        if (name === _name) {\n          matched = true;\n          return false;\n        }\n      }\n  });\n  return matched;\n}\n\nvar _c;\n\n$RefreshReg$(_c, \"Class\");","map":{"version":3,"sources":["/Volumes/Data/sources/solars/frontend/src/validator/libs/class.js"],"names":["dato","require","typeis","classId","inherit","constructor","superConstructor","isCopyStatic","super_","prototype","Object","create","extend","prototypes","isInheritStatic","Function","Error","con","superConstructorIsAFn","Class","the","args","arguments","apply","__classId__","each","key","val","__constructor__","p","s","i","exports","transfer","parentClass","childClass","parentInstanceNameInChild","filter","property","_matches","ret","REG_PRIVATE","name","names","test","length","matched","index","_name","flag","slice"],"mappings":"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","sourcesContent":["/**\n * 类的创建与继承\n * @author ydr.me\n * @create 2014-10-04 15:09\n */\n\n/*===============================\n // 【以前】\n // 创建一个类\n var A = function(){};\n A.prototype.abc = '123';\n\n // 继承一个类\n var B = function(){\n A.apply(this, arguments);\n };\n\n B.prototype = new A();\n B.prototype.def = '456';\n\n // ===>\n\n //【现在】\n var A = klass.create({\n constructor: function(){},\n abc: '123'\n });\n var B = klass.extends(A).create({\n constructor: function(){},\n def: '456'\n });\n ===============================*/\n\n\n/**\n * 类方法\n * @module class\n * @requires dato\n * @requires typeis\n */\n\nvar dato = require('./dato.js');\nvar typeis = require('./typeis.js');\n\nvar classId = 0;\n\n/**\n * 单继承\n * @param {Function} constructor 子类\n * @param {Function} superConstructor 父类\n * @param {Boolean} [isCopyStatic=false] 是否复制静态方法\n * @link https://github.com/joyent/node/blob/master/lib/util.js#L628\n *\n * @example\n * // 父类\n * var Father = function(){};\n *\n * // 子类\n * var Child = function(){\n     *     // 执行一次父类的方法\n     *     Father.apply(this, arguments);\n     *\n     *     // 这里执行子类的方法、属性\n     *     this.sth = 123;\n     * };\n *\n * klass.inherit(Child, Father);\n *\n * // 这里开始写子类的原型方法\n * Child.prototype.fn = fn;\n */\nvar inherit = function (constructor, superConstructor, isCopyStatic) {\n    constructor.super_ = superConstructor;\n    constructor.prototype = Object.create(superConstructor.prototype);\n\n    if (isCopyStatic) {\n        dato.extend(true, constructor, superConstructor);\n    }\n};\n\n\n/**\n * 创建一个类（构造函数）【旧的方法，会在下一个大版本中废弃】\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n */\nvar create = function (prototypes, superConstructor, isInheritStatic) {\n    if (typeis.Function(prototypes)) {\n        prototypes = {\n            constructor: prototypes\n        };\n    }\n\n    if (!typeis.Function(prototypes.constructor)) {\n        throw Error('propertypes.constructor must be a function');\n    }\n\n    var con = prototypes.constructor;\n\n    prototypes.constructor = null;\n\n    var superConstructorIsAFn = typeis.Function(superConstructor);\n    var Class = function () {\n        var the = this;\n        var args = arguments;\n\n        if (superConstructorIsAFn) {\n            superConstructor.apply(the, args);\n        }\n\n        the.__classId__ = classId++;\n        con.apply(the, args);\n    };\n\n    if (superConstructorIsAFn) {\n        inherit(Class, superConstructor, isInheritStatic);\n    }\n\n    dato.each(prototypes, function (key, val) {\n        Class.prototype[key] = val;\n    });\n\n    /**\n     * 原始的 constructor\n     * @type {Function}\n     * @private\n     */\n    Class.prototype.__constructor__ = con;\n\n    /**\n     * 输出的 constructor\n     * @type {Function}\n     */\n    Class.prototype.constructor = Class;\n\n    return Class;\n};\n\n\n/**\n * 类的构造器\n * @param prototypes\n * @param superConstructor\n * @param isInheritStatic\n * @constructor\n */\nvar Class = function (prototypes, superConstructor, isInheritStatic) {\n    var the = this;\n\n    the.p = prototypes;\n    the.s = superConstructor;\n    the.i = isInheritStatic;\n};\n\nClass.prototype = {\n    constructor: Class,\n\n    /**\n     * 类的创建\n     * @param {Object} [prototypes] 原型链\n     * @returns {Function}\n     */\n    create: function (prototypes) {\n        var the = this;\n\n        the.p = prototypes || the.p;\n\n        return create(the.p, the.s, the.i);\n    }\n};\n\n\n/**\n * 类的继承，参考了 es6 的 class 表现\n * 因为 extends 是关键字，在 IE 下会报错，修改为 extend、inherit\n * @param superConstructor\n * @param isInheritStatic\n * @returns {Class}\n */\nexports['extends'] = exports.extend = function (superConstructor, isInheritStatic) {\n    return new Class(null, superConstructor, isInheritStatic);\n};\n\n\n/**\n * 类的创建\n * @param {Object} prototypes 原型链\n * @param {Function} [superConstructor=null] 父类\n * @param {Boolean} [isInheritStatic=false] 是否继承父类的静态方法\n * @returns {Function}\n *\n * @example\n * // 1. 创建一个空原型链的类\n * var A = klass.create(fn);\n *\n * // 2. 创建一个有原型链的类\n * var B = klass.create({\n     *     constructor: fn,\n     *     ...\n     * });\n *\n * // 3. 创建一个子类\n * var C = klass.extend(B).create(fn);\n * var D = klass.extend(C).create({\n     *     constructor: fn,\n     *     ...\n     * });\n */\nexports.create = function (prototypes, superConstructor, isInheritStatic) {\n    var the = this;\n\n    // 上一个级联应该是 extends\n    if (the.constructor === Class && the instanceof Class) {\n        return the.create(prototypes);\n    }\n\n    return new Class(prototypes, superConstructor, isInheritStatic).create();\n};\n\n\n/**\n * 原型转让，将父级的原型复制到子类，\n * 比如写好的一个 Dialog 类有 A、B、C 三个原型方法，\n * 而写好的一个子类 ProductDialog，与 Dialog 的构造参数不一致，无法直接继承，\n * 那么就可以使用原型过渡，子类的 ProductDialog 原本没有 A、B、C 三个实例方法，\n * 只是在内部实例化了一个 Dialog 实例 dialog，那么就可以将 dialog 的原型方法复制到 ProductDialog 实例上\n * 即：`class.transfer(Dialog, ProductDialog, 'dialog')`\n * 结果是：将 Dialog 的原型通过 dialog 实例转让给 ProductDialog\n *\n * @param parentClass {Function|Object} 父级构造函数\n * @param childClass {Function} 子级构造函数\n * @param parentInstanceNameInChild {String} 父级实例在子类的名称\n * @param [filter] {Array} 允许和禁止的公共方法名称\n *\n * @example\n * name 与 ['name'] 匹配\n * name 与 ['!name'] 不匹配\n */\nexports.transfer = function (parentClass, childClass, parentInstanceNameInChild, filter) {\n    dato.each(parentClass.prototype, function (property) {\n        if (!childClass.prototype[property] && _matches(property, filter)) {\n            childClass.prototype[property] = function () {\n                var the = this;\n                var ret = the[parentInstanceNameInChild][property].apply(the[parentInstanceNameInChild], arguments);\n                return ret instanceof parentClass ? the : ret;\n            };\n        }\n    });\n};\n\n\nvar REG_PRIVATE = /^_/;\n\n/**\n * 判断是否匹配\n * @param name {String} 待匹配字符串\n * @param [names] {Array} 被匹配字符串数组\n * @returns {boolean}\n * @private\n */\nfunction _matches(name, names) {\n    names = names || [];\n\n    if (REG_PRIVATE.test(name)) {\n        return false;\n    }\n\n    if (!names.length) {\n        return true;\n    }\n\n    var matched = true;\n\n    dato.each(names, function (index, _name) {\n        var flag = _name[0];\n\n        // !name\n        if (flag === '!') {\n            matched = true;\n\n            if (name === _name.slice(1)) {\n                matched = false;\n                return false;\n            }\n        }\n        // name\n        else {\n            matched = false;\n\n            if (name === _name) {\n                matched = true;\n                return false;\n            }\n        }\n    });\n\n    return matched;\n}"]},"metadata":{},"sourceType":"module"}